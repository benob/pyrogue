<html>
	<head>
		<meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/default.css">
		<script
			charset="UTF-8"
			src="https://highlightjs.org/static/highlight.site.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
<h1>Pyrogue documentation</h1>
<p>Pyrogue is a python interpreter based on <a href="https://www.micropython.org">micropython</a> with a minimalist library for making roguelikes.</p>
<p>Pyrogue comes with the <code>rl</code> module which covers basic roguelike functionalities.
In addition, it comes with the following micropython modules: <a href="https://docs.micropython.org/en/latest/library/math.html">math</a>, <a href="https://docs.micropython.org/en/latest/library/sys.html">sys</a>, <a href="https://docs.micropython.org/en/latest/library/ujson.html">ujson</a>, <a href="https://docs.micropython.org/en/latest/library/ure.html">ure</a>. Other micropython modules are not available and the python language implemented by micropython <a href="https://docs.micropython.org/en/latest/genrst/index.html">differs</a> a bit from standard python. For efficiency, most functions in the <code>rl</code> module do not support keyword arguments.</p>
<p>A typical roguelike programs first imports the <code>rl</code> module, setups a display and invokes run with an update callback.</p>
<pre><code class="language-python">import rl

WIDTH, HEIGHT = 320, 240

def update(event):
	x, y = rl.random_int(0, WIDTH - 1), rl.random_int(0, HEIGHT - 1)
	rl.fill_rect(x, y, 50, 50, rl.random_color())

rl.init_display('example', WIDTH, HEIGHT)
rl.run(update)
</code></pre>
<p><code>rl</code> module contents:</p>
<ul>
<li><a href="#input">Input</a></li>
<li><a href="#drawing">Drawing</a></li>
<li><a href="#random">Random</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#files">Files</a></li>
<li><a href="#utils">Utils</a></li>
</ul>
<h2><a name="input"></a> Input</h2>
<h3><code>rl.run(update_callback, when=rl.CONTINUOUSLY)</code></h3>
<p>Pyrogue's display functions are only honored if called from an update callback which is called every time events occur and the screen needs to be repainted. <code>rl.run()</code> is a blocking function which calls the update function repeatedly according to the <code>when</code> parameter.</p>
<p>Valid values for <code>when</code> are <code>rl.CONTINUOUSLY</code> to recieve updates continuously, <code>rl.ON_KEY</code> to recieve updates when a key is pressed, and <code>rl.ON_MOUSE</code> to receive updates on mouse events. The last two can be combined (<code>rl.ON_KEYS|rl.ON_MOUSE</code>) to recieve both kinds of events.</p>
<p>The update callback is a function taking one parameter which represents the event that triggered it. Events can be:</p>
<ul>
<li>a value &gt; 0 is recieved when a key is pressed. The constants for key identities are the same than <a href="https://wiki.libsdl.org/SDL_Keycode">SDL</a> without the <code>SDL_</code> prefix.</li>
<li><code>rl.QUIT</code> is recieved when the <code>rl.quit()</code> function is called or the window is closed.</li>
<li><code>rl.MOUSE</code> is received when a mouse event occured. <code>rl.mouse()</code> can be used to retrive mouse coordinates.</li>
<li><code>rl.REDRAW</code> is recieved for other events that require a redraw (such as window size changes)</li>
</ul>
<pre><code class="language-python">import rl

x, y = 50, 50

def update(event):
	global x, y

	# move rectangle by 10 pixels in the direction of the pressed key
	if event == rl.LEFT:
		x -= 10
	elif event == rl.RIGHT:
		x += 10
	elif event == rl.UP:
		y -= 10
	elif event == rl.DOWN:
		y += 10
	# or use mouse to move the rectangle
	elif event == rl.MOUSE:
		x, y, button = rl.mouse()

	rl.clear()
	rl.fill_rect(x, y, 50, 50, rl.GREEN)

rl.run(update)
</code></pre>
<h3><code>rl.quit()</code></h3>
<p>Terminates a <code>rl.run()</code> call.</p>
<pre><code class="language-python">def update(event):
	if event &gt; 0:
		rl.quit() # quit on any key
rl.run(update, rl.ON_KEY)
</code></pre>
<h3><code>rl.mouse()</code></h3>
<p>Returns the coordinates of the mouse, as well as the button being pressed. The coordinates are in pixels according to the resolution of the display (see <code>rl.init_display()</code>). The button can be <code>left = 1</code>, <code>middle = 2</code>, <code>right = 3</code>.</p>
<pre><code class="language-python">x, y, button = rl.mouse()
</code></pre>
<h3><code>rl.shift_pressed()</code>, <code>rl.alt_pressed()</code>, <code>rl.ctrl_pressed()</code>, <code>rl.win_pressed()</code></h3>
<p>Returns true if the corresponding modifier key is pressed.</p>
<h2><a name="drawing"></a>Drawing</h2>
<p>The display is a pixel surface resized to fit the pyrogue window. Alt-Enter can put the game in fullscreen. Alt-q force-quits. When starting pyrogue, a default resolution of 320x240 is already setup.</p>
<h3><code>rl.init_display(title, width, height)</code></h3>
<p>Initialize the display with a given window title, and width and height in pixels.
Coordinates follow the standard in graphics: (0, 0) is at the top-left corner, (width, height) is as the bottom-right corner. The display is a 32bit RGB surface which is automatically resized to fit the window.</p>
<pre><code class="language-python">rl.init_display('snake', 320, 240)
</code></pre>
<h3><code>rl.Font(filename, size)</code></h3>
<p>Load a TTF font for writing text on the display. The returned font can be passed to the <code>rl.draw_text()</code> function. Note that only ascii characters in range 32-127 can be drawn. The font object has two read-only attributes: <code>size</code> which is the size passed to the constructor, and <code>line_height</code> which is the line height stored in the font.</p>
<pre><code class="language-python">font = rl.Font('monospace.ttf', 14)
print(font.line_height)
</code></pre>
<p>Note that system resources behind a font (such as the character atlas) are only disposed when the garbage collector is run after memory gets low. When manipulating many fonts, it is a good idea to call <code>del font</code>, where <code>font</code> is a variable holding the font, to explicitly release the resources.</p>
<h3><code>rl.Image(filename, tile_width=8, tile_height=8)</code></h3>
<p>Load a png/jpg image from resources and return an image object. Optionnaly, the size of tiles can be specified. It defaults to 8x8. The returned image object can be passed to drawing functions such as <code>rl.draw_image()</code>. It has two read-only members: <code>width</code> and <code>height</code> and two read-write members: <code>tile_width</code> and <code>tile_height</code>.</p>
<pre><code class="language-python">image = rl.Image('tiles.png', 16, 16)
print(image.width, image.height)
image.tile_width = 8
print(image.tile_width)
</code></pre>
<p>Note that system resources behind an image (such as the pixels uploaded to the GPU) are only disposed when the garbage collector kicks in when memory gets low. When using many images, it is a good idea to call <code>del image</code> when the image is not used anymore.</p>
<h3><code>rl.clear()</code></h3>
<p>Clear the screen by painting it in black.</p>
<pre><code class="language-python">rl.clear()
</code></pre>
<h3><code>rl.draw_image(image, x, y)</code></h3>
<p>Draw an image on the screen. The image parameter is the index of the image loaded in memory. The coordinates are in screen coordinates.</p>
<pre><code class="language-python">rl.draw_image(image, 50, 50)
</code></pre>
<h3><code>rl.draw_tile(image, x, y, tile, fg=0, bg=0)</code></h3>
<p>Draw a tile from an image representing a tileset. The integer index of the image is passed as first parameter. The coordinates of the tile in the image are computed as follows:</p>
<pre><code class="language-python">tiles_per_line = image.width / image.tile_width
tile.x = image.tile_width * (tile % tiles_per_line)
tile.y = image.tile_height * (tile / tiles_per_line)
</code></pre>
<p>The retangle <code>(tile.x, tile.y, image.tile_width, image.tile_height)</code> is then copied at coordinates (x, y) on the screen.
In addition, if specified, the tile background is first painted with <code>bg</code> color, and the non-transparent pixels of the tile are colorized with <code>fg</code> color. Either can be <code>0</code> to skip colorization.</p>
<pre><code class="language-python">tileset = rl.Image('tileset.png', 16, 16)
rl.draw_tile(tileset, 32, 55, 3) # draw tile number 3 at coord (32, 55)
rl.draw_tile(tileset, 5, 5, 17, fg=rl.BLUE, bg=rl.RED) # colorize in addition
</code></pre>
<p>Note that the alpha channel of the image is used to determine transparent pixels.</p>
<h3><code>rl.draw_text(font, x, y, text, color=rl.WHITE, align=rl.ALIGN_LEFT, line_height=0)</code></h3>
<p>Draw text on the screen at coordinates (x, y) using the given color. The font can be either a TTF font loaded with <code>rl.Font()</code> or an image loaded with <code>rl.Image()</code>. If it is an image, it is assumed to be a tileset with ASCII characters as letters.</p>
<p>The align parameter selects the anchoring point of the text compared to the coordinates (x, y). Valid values are <code>rl.ALIGN_LEFT</code>, <code>rl.ALIGN_RIGHT</code> and <code>rl.ALIGN_CENTER</code>.</p>
<p>Note that only characters from 32 to 127 can be printed from TTF fonts. All tiles from 1 to 255 can be printed from a tileset (except <code>\n</code>).</p>
<pre><code class="language-python">font = rl.Font('font.ttf', 10)
image = rl.Image('font.png', 10, 10)
rl.draw_text(font, 0, 0, 'Hello world')
rl.draw_text(image, 0, 20, 'Hello world')
</code></pre>
<h3><code>rl.size_text(font, text)</code></h3>
<p>Compute the width and height of text according to a TTF font.</p>
<pre><code class="language-python">width, height = rl.size_text(font, 'hello world')
</code></pre>
<h3><code>rl.fill_rect(x, y, width, height, color)</code></h3>
<p>Fill a rectangle <code>(x, y, width, height)</code> with the given color.</p>
<pre><code class="language-python">rl.fill_rect(20, 10, 50, 60, rl.color(255, 0, 0))
</code></pre>
<h3><code>rl.draw_rect(x, y, width, height, color)</code></h3>
<p>Draw the outline of a rectangle <code>(x, y, width, height)</code> with the given color.</p>
<pre><code class="language-python">rl.draw_rect(10, 20, 30, 90, rl.color(255, 255, 0))
</code></pre>
<h3><code>rl.draw_line(x1, y1, x2, y2, color)</code></h3>
<p>Draw a stright line between <code>(x1, y1)</code> and <code>(x2, y2)</code> with the given color.</p>
<pre><code class="language-python">rl.draw_line(5, 13, 120, 92, rl.PINK)
</code></pre>
<h3><code>rl.color(r, g, b, a=255)</code></h3>
<p>Make an integer representing an RGBA color from 8-bit components. The values for red (<code>r</code>), green (<code>g</code>), blue (<code>b</code>) and alpha (<code>a</code>) must be between 0 and 255 inclusive. The alpha channel represents the opacity of the color, with 255 the most opaque, and 0 transparent.</p>
<pre><code class="language-python">blue = rl.color(0, 0, 255)
magenta = rl.color(255, 0, 255)
transparent_green = rl.color(0, 255, 0, 128)
</code></pre>
<p>In addition, pyrogue defines constants for the pico8 palette:</p>
<pre><code class="language-python">pico8_colors = [rl.BLACK, rl.DARKBLUE, rl.DARKPURPLE, rl.DARKGREEN,
	rl.BROWN, rl.DARKGRAY, rl.LIGHTGRAY, rl.WHITE,
	rl.RED, rl.ORANGE, rl.YELLOW, rl.GREEN, 
	rl.BLUE, rl.INDIGO, rl.PINK, rl.PEACH,
]
</code></pre>
<h3><code>rl.hsv_color(h, s, v, a=255)</code></h3>
<p>Make an integer representing an RGBA color from HSV components. This function is similar to <code>rl.color()</code> but it takes a hue, saturation and value components. Unlike typical implementations, the hue component is not in degrees, but rather sits between 0 and 255 (corresponding to a 2PI angle).</p>
<pre><code class="language-python">red = rl.hsv_color(0, 255, 255)
</code></pre>
<h3><code>rl.color_r(c)</code>, <code>rl.color_g(c)</code>, <code>rl.color_b(c)</code>, <code>rl.color_a(c)</code></h3>
<p>Return indvidual components from an RGBA color.</p>
<pre><code class="language-python">c = rl.color(255, 0, 0)
print(rl.color_r(c) == 255)
</code></pre>
<h2><a name="random"></a>Random</h2>
<p>The random generator in pyrogue is a <a href="http://www.pcg-random.org/">PCG</a> with a single 64-bit state.
Setting the seed changes the state to a given value. Drawing a random number with any of the functions below changes the state.</p>
<h3><code>rl.random()</code></h3>
<p>Generate a random floating point number between 0 and 1.</p>
<pre><code class="language-python">x = rl.random()
</code></pre>
<h3><code>rl.random_int(a, b)</code></h3>
<p>Generate a random integer between <code>a</code> and <code>b</code> inclusive.</p>
<p>For example, to generate <code>5 &lt;= x &lt;= 7</code>:</p>
<pre><code class="language-python">x = rl.random_int(5, 7)
</code></pre>
<h3><code>rl.roll(dice)</code></h3>
<p>Roll <code>n</code> dices with <code>m</code> faces according to the <code>dice</code> string specification.
The specification the number of rolls followed by 'd' or 'D', followed by the number of faces of the dice. The result is the sum of all rolls. 0 is returned if the specification is invalid.</p>
<pre><code class="language-python">x = rl.roll('3d5')
x = rl.roll('1d12')
</code></pre>
<h3><code>rl.set_seed(s)</code></h3>
<p>Set the random number state to the 64-bit integer <code>s</code>. If <code>s</code> is 0, then the state is set according to the current time.</p>
<pre><code class="language-python">rl.set_seed(123) # set a fixed seed
rl.set_seed(0)   # seed randomly
</code></pre>
<h3><code>rl.get_seed()</code></h3>
<p>Get the 64-bit state of the random generator. Is useful to resume generation after, for example, loading a level.</p>
<pre><code class="language-python">x = rl.get_seed()
</code></pre>
<h3><code>rl.random_color()</code></h3>
<p>Generate a random RGB color.</p>
<pre><code class="language-python">c = rl.random_color()
</code></pre>
<h3><code>rl.random_next()</code>, <code>rl.random_1d(x)</code>, <code>rl.random_2d(x, y)</code>, <code>rl.random_3d(x, y, z)</code></h3>
<p>Generate 32-bit random integers accoring to the internal seed and up to 3 integer dimensions.
These functions yield deterministic noise for a given point in space.</p>
<pre><code class="language-python">x = rl.random_next()
x = rl.random_1d(5)
x = rl.random_2d(5, 42)
x = rl.random_3d(5, 42, 33)
</code></pre>
<h2><a name="arrays"></a>Arrays</h2>
<p>Arrays are fixed-size 2D data structures which allow access to individual elements and have a number of facilities for performing bulk operations. The class also has a few roguelike-focused methods such as computation of field of vision or path finding.</p>
<p>The underlying data type for each cell of the array is a 32-bit signed integer. It can therefore accommodate RGB colors.</p>
<p>Two useful constants are defined, <code>rl.INT_MAX</code> and <code>rl.INT_MIN</code>, which correspond to the largest and smallest values that can be stored in an array.</p>
<h3><code>rl.Array(width, height)</code></h3>
<p>Create a new array of a given size filled with zeros.</p>
<pre><code class="language-python">a = rl.Array(80, 25)
</code></pre>
<h3><code>rl.array_from_string(text)</code>, <code>array.to_string()</code></h3>
<p>Deserialize and serialize and array from and to a string. Useful for saving and restoring array data.</p>
<pre><code class="language-python">a = rl.Array(10, 10)
text = a.to_string()
print(text)
b = rl.array_from_string(text)
print(b)
</code></pre>
<h3><code>array.get(i, j)</code>, <code>array.set(i, j, value)</code>, <code>array[i, j]</code></h3>
<p>Access individual elements of the array. The bracket operator is a shortcut.</p>
<pre><code class="language-python">a = rl.Array(5, 5)
a.set(3, 3, 42)
a[2, 1] = a.get(3, 3)
</code></pre>
<h3><code>array.width()</code>, <code>array.height()</code></h3>
<p>Return the size of the array.</p>
<pre><code class="language-python">a = rl.Array(5, 7)
print(a.width()) # should print 5
</code></pre>
<h3><code>array.print_ascii(chars, fg=None, bg=None)</code></h3>
<p>Print the content of an array to the terminal. Mainly useful for debugging.
Only positive values are displayed. <code>chars</code> is a string where each character corresponds
to the symbol printed for value of the array equals to its index.
<code>bg</code> and <code>fg</code> are optional strings for selecting colors for the corresponding characters.
The colors are denoted by characters '1-9a-f' corresponding to 16 basic ANSI terminal colors.</p>
<pre><code class="language-python">a = rl.Array(3, 5)
a[1, 1] = 1
a.print_ascii('.#', '12', 'ba')
</code></pre>
<h3><code>print(array)</code></h3>
<p>Print the content of an array using the standard python print. The array is presented as a list of lists.</p>
<pre><code class="language-python">a = rl.Array(2, 2)
print(a)
</code></pre>
<h3><code>array.copy()</code></h3>
<p>Return a copy of the array which can be modified independently.</p>
<pre><code class="language-python">b = a.copy()
b[1, 1] = 2
print(a, b) # prints different content for a and b
</code></pre>
<h3><code>array.copy_to(dest)</code></h3>
<p>Copy the values of an array to another array.</p>
<pre><code class="language-python">a.copy_to(b)
</code></pre>
<h3><code>array.copy_masked(dest, mask, keep=1)</code></h3>
<p>Copy the values of an array to another array, but only copy those values for which the mask array is equal to <code>keep</code>. All arrays must be the same size.</p>
<pre><code class="language-python">b = rl.Array(a.width(), a.height())
a.copy_masked(b, mask)
print(b)
</code></pre>
<h3><code>array.equals(value)</code></h3>
<p>Returns a new array with 1 in every cell containing the value in the original array, 0 otherwise.</p>
<pre><code class="language-python">walls = level.equals(1)
</code></pre>
<h3><code>array.fill(value)</code></h3>
<p>Fill an array with a given integer value.</p>
<pre><code class="language-python">a = rl.Array(10, 10)
a.fill(5)
</code></pre>
<h3><code>array.replace(value, other)</code></h3>
<p>Replace a value by another in an array.</p>
<pre><code class="language-python">a.replace(5, 7) # replaces all occurrences of 5 with 7.
</code></pre>
<h3><code>array.add(value, blocking=INT_MAX)</code>, <code>array.mul(value, blocking=INT_MAX)</code></h3>
<p>Add (respectively multiply) a scalar value to each cell of an array.
Values which equal <code>blocking</code> are not modified.</p>
<pre><code class="language-python">a.add(3) 
a.mul(2)
</code></pre>
<h3><code>array.min()</code>, <code>array.max()</code></h3>
<p>Return the mininum (respectively maximum) value of an array.</p>
<pre><code class="language-python">min = a.min()
max = a.max()
</code></pre>
<h3><code>array.argmin()</code>, <code>array.argmax()</code></h3>
<p>Returns the location of the first encountered smallest (respectively largest) value in the array.</p>
<pre><code class="language-python">x_min, y_min = a.argmin()
x_max, y_max = a.argmax()
</code></pre>
<h3><code>array.random_int(a, b)</code></h3>
<p>Fill an array with random numbers between <code>a</code> and <code>b</code> inclusive.</p>
<pre><code class="language-python">a.random_int(0, 42)
</code></pre>
<h3><code>array.random_2d(x, y)</code></h3>
<p>Fill an array with deterministic noise at <code>(x, y)</code> offsetted by the corresponding cell index.
See <code>rl.random_2d()</code> for more information.</p>
<pre><code class="language-python">a.random_2d(5, 3) 
</code></pre>
<h3><code>array.random()</code></h3>
<p>Fill an array with random 32-bit values.</p>
<pre><code class="language-python">a.random()
</code></pre>
<h3><code>array.line(x1, y1, x2, y2, value)</code></h3>
<p>Set all elements of an array on a straight line with a given value. Coordinates of the line ends are cell indices in the array.</p>
<pre><code class="language-python">a.line(1, 3, 5, 7, -2) # draw a line with the value -2
</code></pre>
<h3><code>array.rect(x, y, width, height, value)</code></h3>
<p>Fill a rectangular area in a rectangle with a given value.</p>
<pre><code class="language-python">a.rect(0, 0, 2, 3, 42) # fill a retangle with value 42
</code></pre>
<h3><code>array.can_see(x1, y1, x2, y2, blocking=1)</code></h3>
<p>Tests whether cell (x1, y1) has line of sight to cell (x2, y2) in the given array, using <code>blocking</code> as wall value. Note that the algorithm used for computing lines is not symmetric, that is <code>array.can_see(x1, y1, x2, y2)</code> is not necessarily the same as <code>array.can_see(x2, y2, x1, y1)</code>. Returns <code>True</code> if the destination can be seen from the source, <code>False</code> otherwise.</p>
<pre><code class="language-python">if level.can_see(player.x, player.y, monster.x, monster.y):
	print('I can see a monster.')
</code></pre>
<h3><code>array.field_of_view(x, y, radius, blocking=1)</code></h3>
<p>Computes the field of view around a point in an array, considering that all cells with value <code>blocking</code>, and returns an array where all cells with value 1 are visible, other cells have value 0.</p>
<pre><code class="language-python">fov = level.field_of_view(player.x, player.y, 10)
</code></pre>
<h3><code>array.dijkstra()</code></h3>
<p>Applies the <a href="http://roguebasin.roguelikedevelopment.org/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">djikstra map</a> algorithm to the array until convergence. Each cell is set to the value of its lowest neighbor plus one until convergence. Negative cells are ignored. To build a path finder, set targets to 0, walls to -1, and passable floor to <code>rl.INT_MAX</code>.</p>
<pre><code class="language-python">a.fill(rl.MAX_INT)
a[5, 5] = 0
a.djikstra()
# a now contains the distance from each of its 
# cells to (5, 5) using nonblocking paths
</code></pre>
<p>This algorithm loops over the array as many times as there are steps in the longest path in the level.</p>
<h3><code>array.cell_automaton(definition, warp=False)</code></h3>
<p>Applies one step of a <a href="https://en.wikipedia.org/wiki/Life-like_cellular_automaton">cellular automaton</a> to the array. The function assumes that the array is filled with 0 (dead) or 1 (alive). Then, for each cell it computes its new state (dead or alive) depending on the definition which states how the cell changes depending on its neighbors. It uses the Golly notation: <code>Bx/Sy</code> where <code>x</code> and <code>y</code> are strings of digits from 0 to 8. <code>B</code> stands for birth and <code>S</code> stands for survival. If a cell is dead and its number of alive neighbors is in <code>x</code>, then it is set to alive. If a cell is alive and its number of alive neighbors is not in <code>y</code>, then it is set to dead.</p>
<pre><code class="language-python">a = rl.Array(100, 100)
a.random_int(0, 1)

# 10 steps of the game of life automaton
for i in range(10):
	a.cell_automaton('B3/S23') 
</code></pre>
<h3><code>array.shortest_path(x1, y1, x2, y2, blocking=1)</code></h3>
<p>Computes the shortest path between two points in an array, considering that cells containing the <code>blocking</code> value cannot be moved through. Diagonal movements are authorized. If a path cannot be found, <code>None</code> is returned.</p>
<pre><code class="language-python">for x, y in a.shortest_path(3, 2, 5, 6):
	print(x, y)
</code></pre>
<h3><code>array.find_random(needle, tries=100)</code></h3>
<p>Return the location of a value (the needle) in an array. Locations are tested randomly until one is found up to the number of specified tries.</p>
<pre><code class="language-python">x, y = a.find_random(1)
</code></pre>
<h3><code>array.place_random(needle, value, tries=100)</code></h3>
<p>Replace an occurrence of the needle with the given value in an array. Works similarly to <code>array.find_random()</code>.</p>
<pre><code class="language-python">a.place_random(1, 42)
</code></pre>
<h3><code>rl.draw_array(image, x, y, x_shift=0, y_shift=0, mapping=None, fg=None, bg=None)</code></h3>
<p>Draw an array of tiles on the screen at coordinates x, y. By default, coordinates are shifted by the <code>tile_width</code> and <code>tile_height</code> of the image, but other values can be specified in <code>x_shift</code> and <code>y_shift</code>. Optionaly, values can be mapped for selecting tiles and coloring them with foreground (<code>fg</code>) and background (<code>bg</code>) colors.</p>
<pre><code class="language-python">rl.draw_array(tileset, x, y, mapping=[1,2,3], fg=[rl.RED, rl.BLUE, rl.GREEN])
</code></pre>
<h3><code>rl.array_to_image(array, tile_width=8, tile_height=8)</code></h3>
<p>Create an image from the values of an array intepreted as RGBA colors.</p>
<pre><code class="language-python">a = rl.Array(320, 240)
a.fill(rl.RED)
image = rl.array_to_image(a)
</code></pre>
<h3><code>rl.image_to_array(image)</code></h3>
<p>Create an array from the pixels of an image. Each value of the array represents an RGBA color.</p>
<pre><code class="language-python">image = rl.load_image('tileset.png')
a = rl.image_to_array(image)
</code></pre>
<h2><a name="files"></a>Files</h2>
<p>Pyrogue assumes two locations for storing files. The &quot;ressources&quot; location is a bundle of read-only assets such as images, fonts, game data and python scripts. It can be a directory, a zip or can be embedded in the pyrogue executable. The &quot;preferences&quot; location is a directory where game saves or high-scores can be saved and loaded later. It sits in the user directory returned by <code>SDL_GetPrefPath()</code> under a <code>pyrogue</code> directory.</p>
<h3><code>rl.load_asset(filename)</code></h3>
<p>Load asset from resources. Filename can be a path including directories. Returns a bytes object with the loaded data or <code>None</code> if the asset could not be loaded.</p>
<pre><code class="language-python">data = rl.load_asset('data.txt')
</code></pre>
<p>Note that assets cannot be written.</p>
<h3><code>rl.set_app_name(name)</code></h3>
<p>Set the name of the app for loading and saving preferences in the user directory.</p>
<pre><code class="language-python">rl.set_app_name('my-game')
</code></pre>
<h3><code>rl.load_pref(filename)</code></h3>
<p>Load a file from the user directory. As with <code>rl.load_assets()</code>, the content of the file is returned as a bytes object or <code>None</code> if the file could not be loaded.</p>
<pre><code class="language-python">high_scores = rl.load_pref('high_scores.txt') 
</code></pre>
<p>On linux, that directory is <code>$XDG_CONFIG_DIR/pyrogue/&lt;app-name&gt;</code> where <code>&lt;app-name&gt;</code> is changed with <code>rl.set_app_name(name)</code>.</p>
<h3><code>rl.save_pref(filename, content)</code></h3>
<p>Save a file to the user directory. The content passed to the function must be a bytes-like object such as a string. Python objects can be encoded to string with ujson.</p>
<pre><code class="language-python">import ujson
scores = [1, 2, 3, 4]
rl.save_pref('high_scores.txt', ujson.dumps(scores))
</code></pre>
<h2><a name="utils"></a>Utils</h2>
<h3><code>rl.walk_line_start(x1, y1, x2, y2)</code>, <code>rl.walk_line_next()</code></h3>
<p>Iterate over a straight line from (x1, y1) to (x2, y2). <code>rl.walk_line_next()</code> returns a tuple of coordinates for each point and <code>None</code> when it is finished iterating.</p>
<pre><code class="language-python">rl.walk_line_start(10, 10, 20, 30)
while True:
	result = rl.walk_line_next()
	if result is None:
		break
	x, y = result
	# use (x, y)
</code></pre>
<p>The same algorithm as in <code>array.line()</code> is used.</p>
	</body>
</html>
